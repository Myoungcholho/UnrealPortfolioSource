# 📘언리얼 3D 액션 게임 프로젝트
<br>
<img align="right" width="420"
     src="https://github.com/user-attachments/assets/c4b862bb-c273-42a1-a2c1-ee171d5a8244"
     alt="Unreal Engine5 Action Game" />

- 소개 영상: [포트폴리오 영상](https://www.youtube.com/watch?v=xfAdjhyRtIA)
- 개발 기간: 2025.01.06 ~ 2025.04.02 (87일)  
- 개발 인원: 1명
- 핵심 요약: 언리얼 엔진을 활용한 3D 액션 게임  
- 개발 환경:
  - 언어: C++
  - 엔진: Unreal Engine 5

<br clear="both"/>

# 📘목차
- [개발 계기](#개발-계기)
- [아쉬웠던 점](#아쉬웠던-점)
- [프로젝트에서 얻은 것](#프로젝트에서-얻은-것)
- [구현 내용](#구현-내용)
- [문제 해결 경험(트러블 슈팅)](#문제-해결-경험트러블-슈팅)
- [핵심 주요 코드](#핵심-주요-코드)

# 📘개발 계기
### 1. 언리얼 엔진을 ‘개발자 관점’에서 익히기 위해

사용하기 편한 언리얼의 블루프린트·에디터 기능 뒤에서</br>
어떤 구조와 흐름이 돌아가는지 궁금해, 직접 3D 액션 게임을 만들며</br>
C++ API와 액터·컴포넌트·컨트롤러 구조를 몸으로 익히고자 했습니다.</br>

### 2. Unity 3D 액션 RPG를 포팅하며 전투 설계를 고도화하기 위해

이전에 Unity로 만들었던 3D 액션 RPG 전투 시스템을 언리얼로 포팅하면서,</br>
단순 이식이 아니라 타격 판정·상태·카메라·연출을</br>
더 정교하게 설계해 재사용 가능한 전투 구조로 발전시키고자 했습니다.</br>

### 3. 디자인 패턴 기반의 유연한 구조 설계 능력을 확장하기 위해

상태 패턴, 전략 패턴 등을 실제 코드에 적용해 무기·스킬·AI를</br>
쉽게 추가·교체할 수 있는 구조를 실전에서 연습하고,</br>
변경과 확장이 잦은 액션 게임에 맞는 아키텍처 설계 역량을 키우기 위해 시작한 프로젝트입니다.</br>

# 📘아쉬웠던 점
### 1. 언리얼 아키텍처에 대한 깊은 이해 없이 프로젝트를 시작한 점

언리얼의 GC 동작 원리에 대한 이해가 부족한 상태에서 프로젝트를 진행했습니다.</br>
Broadcast 호출 시 GC에 의해 수거된 객체를 참조해 크래시가 발생하는 문제를 겪었고,</br>
문제가 발생한 뒤에야 UPROPERTY와 GC 추적 구조를 제대로 파고들게 되었습니다.</br>

이후로는 기능을 쓰기 전에 엔진이 그 기능을 내부에서 어떻게 관리하는지부터 보는 습관을 들였습니다.</br>

---

### 2. 미세 버그를 “나중에 고치자”고 넘겼던 점
적 스트레이프 대기 초기 구현 때,</br>
옆으로 이동할 때 단 1프레임 동안 고개가 휙 돌아가는 미세한 끊김 문제가 있었습니다.</br>
당시에는 “전체 흐름은 잘 돌아가니 나중에 보자”고 넘겼는데,</br>

마무리 단계에서 디테일을 점검하다 보니</br>
그 1프레임의 까딱거림이 플레이어 입장에서는 꽤 거슬리는 버그라는 걸 뒤늦게 느꼈습니다.</br>

문제를 인지한 시점에 바로 원인 분석과 수정을 했더라면</br>
더 적은 비용으로 해결할 수 있었을 것입니다.</br>
이 경험 이후, 특히 연출·모션 관련해서는</br>
“개발자 기준”이 아니라 “플레이어 눈높이”에서 미세 버그도 즉시 정리하는 쪽으로 태도를 바꾸었습니다.</br>

---

### 3. 문제 해결 과정을 충분히 기록하지 않았던 점
이번 언리얼 프로젝트에서는</br>
발생했던 문제와 해결 과정을 체계적으로 기록하지 않아,</br>
나중에 코드를 복기하거나 정리할 때 시간이 더 걸렸습니다.</br>

이후 DX 프로젝트부터는</br>
버그 원인과 해결 과정을 주석이나 블로그·노트 형태로 꼼꼼히 남기면서,</br>
복기·정리 시간과 실수 반복을 크게 줄일 수 있었습니다.</br>

현재는 “문제 해결 자체”뿐 아니라 “과정을 기록해 재사용 가능한 자산으로 남기는 것”까지</br>
개발의 한 단계로 보고 습관화하려고 노력하고 있습니다.</br>

# 📘프로젝트에서 얻은 것
### 1. 구조 설계 & 디자인 패턴 활용 역량
옵저버, 팩토리, 커맨드 등의 디자인 패턴을 실제 코드에 적용해 보면서</br>
플레이어·아이템·UI 등 객체의 책임을 명확히 나누고,</br>
이후 확장이 쉬운 계층 구조를 설계하는 능력을 키웠습니다.</br>

그 과정에서 한 클래스에 기능이 과도하게 몰리지 않도록 조절하고,</br>
읽기 쉽고 유지보수가 용이한 구조를 의식적으로 만드는 습관을 갖게 되었습니다.</br>

---

### 2. 데이터 중심 구조 설계 경험
데이터 에셋과 테이블을 활용해</br>
코드 수정 없이도 밸런스 수치를 조정·운영할 수 있는 데이터 구조를 설계했습니다.</br>

이를 통해 데이터의 정의·등록·관리 책임을 코드와 분리하는 감각을 익혔고,</br>
운영·밸런스 관점에서 다루기 쉬운 구조가 무엇인지에 대해 고민할 수 있었습니다.</br>

---

### 3. 액션 게임 콘텐츠 개발 경험

이펙트 회전 방향 계산, 커맨드 입력 구조, 상태 중첩 관리, 피격 이벤트 처리 등</br>
액션 게임 전투 콘텐츠를 직접 구현하며,</br>
그 과정에서 필요한 수학적 개념, 엔진 기능 활용 능력, 실전 노하우를 함께 쌓았습니다.</br>

---

### 4. MVVM 기반 UI 구조 설계 역량

이전 유니티 프로젝트에서는 UI와 로직이 강하게 결합되어,</br>
UI 코드가 쉽게 비대해지는 문제가 있었습니다.</br>

이번에는 MVVM 패턴을 도입해 체력 변화 같은 게임 로직을</br>
뷰모델을 통한 이벤트 연동 구조로 분리했고,</br>
그 과정에서 UI를 보다 유연하고 안전하게 설계하는 방법을 체감했습니다.</br>

# 📘구현 내용
- 캐릭터 & 전투 시스템: 상태/무기/스테미나/가드/피격/처형/커맨드 공격 로직 구현</br>
- 아이템 & 인벤토리: 드랍·획득·사용 및 슬롯/인벤토리 구조 설계</br>
- UI 시스템(MVVM): 체력/스테미나/아이템 슬롯 UI 및 데이터 바인딩 구조 구현</br>
- AI & 전투 시스템: 적 계층 구조, 중앙 토큰 기반 전투 관리, 상태 머신 구현</br>


# 📘문제 해결 경험(트러블 슈팅)
### 1. 빠른 공격 모션에서 타격 누락 문제 (Hit Detection 안정화)

- 문제 상황

빠른 공격 모션에서 간헐적으로 적이 타격되지 않는 현상 발생했습니다.</br>
애니메이션 상 타격 위치는 정확했지만,</br>
실제 플레이에서는 타격이 누락되는 경우가 종종 발생했습니다.</br>

- 원인 분석
  
무기 Collision을 애니메이션의 특정 구간에서만 </br>
Enable/Disable 하는 방식으로 판정을 처리하고 있었습니다.</br>

공격 속도가 빠르고 이동 범위가 큰 모션에서는 프레임 사이 이동량이 커지면서,</br>

Collision이 활성화된 구간에 적이 들어왔다가 프레임 단위 샘플링을 건너뛰고</br>
비활성화되는 타이밍 문제가 발생했습니다.</br>

즉, Collision Overlap 이벤트만으로는 빠른 모션에서 안정적인 타격을 보장하기 어려운 구조였습니다.</br>

- 해결
  
기존의 Collision 단일 판정 방식을, Collision + Trace를 병행하는 Hybrid 방식으로 확장했습니다.</br>

매 프레임마다 Collider의 이전 위치와 현재 위치를 기준으로 LineTrace를 수행하여,</br>
Collision이 놓친 대상도 궤적을 따라 추가로 감지해 타격하도록 수정했습니다.</br>

또한 Trace 중복을 방지하기 위해, 이미 피격된 대상은 별도로 저장하여</br>
한 번의 공격에서 중복 타격이 발생하지 않도록 처리했습니다.</br>


- 결과
  
빠른 공격에서 발생하던 타격 누락 문제를 해소하고,</br>
프레임 의존적인 판정을 궤적 기반 판정으로 전환하여 </br>
FPS 변동과 무관하게 안정적인 히트 판정을 확보했습니다.</br>

이로 인해 불안정한 피격 판정에서 오는 답답함이 사라지고,</br>
공격 한 번 한 번이 기대한 대로 맞아 들어가는 전투 감각을 만들 수 있었습니다.</br>

- 배운 점
  
이번 문제를 통해 Collision Overlap 하나만으로는 항상 충분한 해답이 될 수 없고,</br>
언리얼이 제공하는 여러 기능을 상황에 맞게 조합하는 설계가 중요하다는 것을 배웠습니다.</br>

또한 문제 해결은 단순히 코드를 미세 조정하는 것이 아니라,</br>
“프레임 단위 샘플링”이 아니라 “공격 궤적 전체를 어떻게 판정할 것인가”</br>
처럼 판정 개념 자체를 다시 정의하는 관점 전환에서 출발해야 한다는 점을 체감했습니다.</br>

콘텐츠 프로그래머는 이러한 도구들을 폭넓게 이해하고,</br>
필요에 따라 과감히 조합·응용하여 더 나은 플레이 감각을 설계하는 역할이라고 생각합니다.</br>

---

### 2. 암살 몽타주 관리 구조 문제 → 세트 기반 구조로 리팩토링

- 문제 상황

암살 기능에서 공격자 몽타주와 피격자 몽타주를 별도로 관리하는 구조를 사용했습니다.</br>

처형 타입이 늘어날수록 각 몽타주를 개별적으로 설정·매핑해야 하는 반복 작업이 늘어났고,</br>
그 과정에서 공격자/피격자 연출 세팅 실수와 유지보수 비용 증가 문제가 드러났습니다.</br>

- 원인 분석
  
초기 설계에서는 피격 모션이 몬스터마다 달라질 수 있다는 전제로</br>
공격자/피격자 몽타주를 완전히 분리 관리하는 방식을 선택했습니다.</br>

하지만 처형 종류가 늘어나면서 인덱스·타입 매핑이 점점 복잡해졌고,</br>
데이터가 여러 곳에 흩어지면서 실수 여지가 큰 구조가 되었습니다.</br>

- 해결
  
처형 기능을 단일 세트 데이터 기반 구조로 리팩토링했습니다.</br>

공격자 몽타주, 피격자 몽타주, 카메라 블렌드 데이터를 하나의 세트로 묶어 관리하고,</br>
암살 요청 시 암살 매니저가 적절한 세트를 선택해 캐릭터에 전달하는 방식으로 변경했습니다.</br>

이로써 암살 관련 데이터는 캐릭터가 직접 들고 있지 않고,</br>
중간에서 조율하는 매니저가 중앙에서 책임지고 관리하도록 구조를 재편했습니다.</br>

- 결과
  
공격자/피격자/카메라 설정을 하나의 세트로 관리하면서,</br>
새로운 처형을 추가할 때도“세트 하나 등록”만으로 연출 구성이 가능해졌습니다.</br>

인덱스 매핑 실수 가능성을 줄였고,</br>
캐릭터는 “암살 데이터 소유자”가 아니라 매니저가 제공하는</br>
세트를 소비하는 쪽으로 역할이 명확히 분리되었습니다.</br>

- 배운 점
  
이 구조에 도달하기까지 총 세 번의 리팩토링을 거쳤습니다.</br>

처음부터 잘 설계했으면 좋았겠지만, 이 설계에 도달하기 위해서는</br>
오히려 이 과정을 직접 겪어 보는 시간이 필요했다고 느꼈습니다.</br>

그래서 저는 시행착오가 결코 무의미한 작업이 아니라고 생각합니다.</br>

실패했던 구조와 그 수정 과정에서 쌓인 기록과 경험이,</br>
결국 더 나은 설계를 선택하는 기준과 감각이 되었음을 느꼈습니다.</br>

이번 경험을 통해 “처음부터 완벽하게 짜는 것”뿐 아니라</br>
부딪히고 고쳐 나가는 과정 자체도 개발자의 중요한 자산이라는 점을 다시 한 번 체감했습니다.</br>

### 3. Delegate / GC Crash 문제 (UPROPERTY 관리 문제)

- 문제 상황
  
인벤토리 갱신 이벤트를 UI 위젯 등 외부에서 받아 처리하기 위해 델리게이트를 사용했습니다.</br>

초기에는 정상 동작했지만, 플레이 시간이 길어지고 인벤토리 변경이 여러 번 일어나는 상황에서</br>
델리게이트 Braodcast 시점에 크래시가 발생했습니다.</br>

- 원인 분석
  
인벤토리 아이템을 TArray<UCInventoryItem*> 형태로 저장하고 있었는데,</br>
이 배열 멤버에 UPROPERTY가 선언되어 있지 않아 GC가 배열 안의</br>
UObject 참조를 추적하지 못한 것이 문제였습니다.</br>

- 해결
  
아이템 객체 배열을 UPROPERTY()를 선언해,</br>
GC가 배열 및 그 내부 객체를 올바르게 추적하도록 변경했습니다.</br>

- 결과
  
장시간 플레이 및 인벤토리 갱신이 반복되는 상황에서도</br>
더 이상 델리게이트 Broadcast 시점 크래시가 발생하지 않게 되었습니다.</br>

- 배운 점
  
일부 포인터 멤버는 UPROPERTY 없이도 문제가 없었던 반면,</br>
이번처럼 TArray<UObject*> 형태로만 들고 있는 경우에는</br>
GC의 추적 대상에서 빠질 수 있다는 점을 몸으로 확인했습니다.</br>

RootSet이나 월드에 직접 배치된 객체들은 다른 경로로 GC가 인지하고 있었기 때문에,</br>
“지금까지 괜찮았으니 앞으로도 괜찮겠지”라는 안일한 습관이 문제를 키운 셈이었습니다.</br>

이번 경험을 통해 언리얼의 GC와 UPROPERTY 시스템이 언제,</br>
어떻게 객체를 추적하는지에 대한 이해가 필수적이라는 것을 느꼈고,</br>

엔진이 제공하는 메모리·생명주기 관리 방식을 정확히 이해하지 못한 채 사용하는 것은</br>
언젠가 치명적인 버그로 돌아올 수 있다는 점을 다시 한 번 깨달았습니다.</br>

### 4. AI 상태 전이 타이밍 문제 (BehaviorTree / AI Flow 개선)

- 문제 상황
  
여러 AI가 동시에 한 플레이어를 둘러싸고 싸우는 전투에서</br>
각 AI가 Approach / Action / Strafe 같은 상태를 기준으로 움직이도록 설계했습니다.</br>

하지만 실제 플레이에서는 분명히 Approach 상태인데도,</br>
다른 상태 조건이 먼저 만족되면서 의도하지 않은 움직임이 나오는 문제가 발생했습니다.</br>

- 원인 분석
  
처음의 구조는 각 AI가 자기 State컴포넌트의 상태를보고 BT Service/Task안에서</br>
”지금은 붙어도 되는지 / Strafe 해야 하는지”를 판단하고 결과에 따라 이동/회전/공격을 수행하고 있었습니다.</br>

문제는 BT의 업데이트 순서/ Abort 타이밍과 얽히면서 상태가 변경됨에도</br>
조건을 만족하지 않아 상태가 재변경되는 상태가 발생했습니다.</br>

이를 막기 위해 조건/방어 코드를 계속 추가하며 상태 전이 타이밍과</br>
조건 분기가 점점 더 꼬여가는 구조가 되었습니다.</br>

문제의 본질은 업데이트 순서로 상태의 변경 순서가 지연됨에 재변경되는 문제였습니다.</br>

- 해결
  
상태 플래그에 직접 의존해 “붙을지 말지”를 판단하는 대신,</br>
중앙에서 토큰을 배분하는 방식으로 구조를 바꾸었습니다.</br>

전투용 매니저를 두고 모든 AI를 등록해 둔 뒤,</br>
AI가 타겟에 접근하고 싶을 때 매니저에게 “접근 토큰”을 요청하도록 했습니다.</br>

그 결과, 토큰을 받은 AI만 Approach 상태로 타겟에 붙을 수 있고</br>
나머지는 대기·우회 등 다른 플로우로 이동하게 설계했습니다.</br>

- 결과

근접 슬롯이 안정적으로 관리되면서 특정 타겟에게</br>
과도하게 몰리거나, 들락날락하는 불안정한 움직임이 사라졌습니다.</br>

BehaviorTree에서는 복잡한 상태 조합 대신</br>
“토큰 보유 여부”만 보고 판단하면 되기 때문에 트리 구조와 조건이 단순해졌습니다.</br>

전투 연출(몇 명이 붙고, 몇 명은 거리 유지할지 등)을</br>
매니저 설정만으로조절할 수 있어, 밸런싱과 튜닝이 용이해졌습니다.</br>

- 배운 점
  
이번 문제를 통해 FSM의 장단점을 확실히 체감했습니다.</br>

직접 겪어 보니, FSM으로 모든 세부 상태를 관리하려 하면 조건과 분기가 금방 폭발하고,</br>
FSM은 큰 흐름을 나누는 용도에 두고, 세부 로직은 토큰 매니저나 블랙보드 같은</br>
별도 통제 수단과 조합하는 쪽이 더 적절하다는 걸 느꼈습니다.</br>

# 📘핵심 주요 코드
